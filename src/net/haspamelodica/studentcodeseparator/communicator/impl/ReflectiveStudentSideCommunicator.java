package net.haspamelodica.studentcodeseparator.communicator.impl;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import net.haspamelodica.studentcodeseparator.communicator.StudentSideCommunicator;

public class ReflectiveStudentSideCommunicator implements StudentSideCommunicator<Object>
{
	@Override
	public Object callConstructor(String classname, Class<?>[] paramTypes, Object... args)
	{
		return wrap(() -> Class.forName(classname).getConstructor(paramTypes).newInstance(args));
	}

	@Override
	public <R> R callStaticMethod(String classname, String name, Class<R> returnType, Class<?>[] paramTypes, Object... args)
	{
		return wrap(() ->
		{
			Method method = lookupMethod(classname, name, paramTypes, returnType);
			@SuppressWarnings("unchecked") //we checked the class manually
			R result = (R) method.invoke(null, args);
			return result;
		});
	}

	@Override
	public <F> F getStaticField(String classname, String name, Class<F> fieldType)
	{
		return wrap(() ->
		{
			Field field = lookupField(classname, name, fieldType);
			@SuppressWarnings("unchecked") //we checked the class manually
			F result = (F) field.get(null);
			return result;
		});
	}

	@Override
	public <F> void setStaticField(String classname, String name, Class<F> fieldType, F value)
	{
		wrap(() -> lookupField(classname, name, fieldType).set(null, value));
	}

	@Override
	public <R> R callInstanceMethod(String classname, String name, Class<R> returnType, Class<?>[] paramTypes, Object ref, Object... args)
	{
		return wrap(() ->
		{
			Method method = lookupMethod(classname, name, paramTypes, returnType);
			//TODO check if is instance method
			@SuppressWarnings("unchecked") //we checked the class manually
			R result = (R) method.invoke(ref, args);
			return result;
		});
	}

	@Override
	public <F> F getField(String classname, String name, Class<F> fieldType, Object ref)
	{
		return wrap(() ->
		{
			Field field = lookupField(classname, name, fieldType);
			//TODO check if is instance field
			@SuppressWarnings("unchecked") //we checked the class manually
			F result = (F) field.get(ref);
			return result;
		});
	}

	@Override
	public <F> void setField(String classname, String name, Class<F> fieldType, Object ref, F value)
	{
		//TODO check if is instance field
		wrap(() -> lookupField(classname, name, fieldType).set(ref, value));
	}

	private <F> Field lookupField(String classname, String name, Class<F> fieldType) throws NoSuchFieldException, ClassNotFoundException
	{
		Field field = Class.forName(classname).getDeclaredField(name);
		if(!field.getType().equals(fieldType))
			throw new IllegalArgumentException("Field type mismatch");
		//isAccessible is deprecated. We can tolerate the inefficiency generated by always setting accessible.
		field.setAccessible(true);
		return field;
	}

	private Method lookupMethod(String classname, String name, Class<?>[] paramTypes, Class<?> returnType) throws NoSuchMethodException, ClassNotFoundException
	{
		Method method = Class.forName(classname).getDeclaredMethod(name, paramTypes);
		if(!method.getReturnType().equals(returnType))
			throw new IllegalArgumentException("Return type mismatch");
		//isAccessible is deprecated. We can tolerate the inefficiency generated by always setting accessible.
		method.setAccessible(true);
		return method;
	}

	private void wrap(ThrowingRunnable body)
	{
		wrap(() ->
		{
			body.run();
			return null;
		});
	}
	private <R> R wrap(ThrowingSupplier<R> body)
	{
		try
		{
			return body.get();
		} catch(InvocationTargetException | InstantiationException | IllegalAccessException | NoSuchMethodException | NoSuchFieldException
				| ClassNotFoundException e)
		{
			//TODO throw correct exception type
			throw new RuntimeException(e);
		}
	}

	private static interface ThrowingRunnable
	{
		public void run() throws InvocationTargetException, InstantiationException, IllegalAccessException, IllegalArgumentException,
				NoSuchMethodException, NoSuchFieldException, SecurityException, ClassNotFoundException;
	}
	private static interface ThrowingSupplier<R>
	{
		public R get() throws InvocationTargetException, InstantiationException, IllegalAccessException, IllegalArgumentException,
				NoSuchMethodException, NoSuchFieldException, SecurityException, ClassNotFoundException;
	}
}
