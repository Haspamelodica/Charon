package net.haspamelodica.studentcodeseparator.reflection;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Stream;

public class ReflectionUtils
{
	public static <T> T callConstructor(Class<T> clazz, List<Class<?>> paramTypes, List<Object> args)
	{
		return doChecked(() -> clazz.getConstructor(paramTypes.toArray(Class[]::new)).newInstance(args.toArray()));
	}

	public static <R> R callStaticMethod(Class<?> clazz, String name, Class<R> returnType, List<Class<?>> paramTypes, List<Object> args)
	{
		return doChecked(() ->
		{
			Method method = lookupMethod(clazz, name, paramTypes, returnType);
			@SuppressWarnings("unchecked") //we checked the class manually
			R result = (R) method.invoke(null, args.toArray());
			return result;
		});
	}

	public static <F> F getStaticField(Class<?> clazz, String name, Class<F> fieldType)
	{
		return doChecked(() ->
		{
			Field field = lookupField(clazz, name, fieldType);
			@SuppressWarnings("unchecked") //we checked the class manually
			F result = (F) field.get(null);
			return result;
		});
	}

	public static <F> void setStaticField(Class<?> clazz, String name, Class<F> fieldType, F value)
	{
		doChecked(() -> lookupField(clazz, name, fieldType).set(null, value));
	}

	public static <T, R> R callInstanceMethod(Class<T> clazz, String name, Class<R> returnType, List<Class<?>> paramTypes, T receiver, List<Object> args)
	{
		return doChecked(() ->
		{
			Method method = lookupMethod(clazz, name, paramTypes, returnType);
			//TODO check if is instance method
			@SuppressWarnings("unchecked") //we checked the class manually
			R result = (R) method.invoke(receiver, args.toArray());
			return result;
		});
	}

	public static <T, F> F getField(Class<T> clazz, String name, Class<F> fieldType, T receiver)
	{
		return doChecked(() ->
		{
			Field field = lookupField(clazz, name, fieldType);
			//TODO check if is instance field
			@SuppressWarnings("unchecked") //we checked the class manually
			F result = (F) field.get(receiver);
			return result;
		});
	}

	public static <T, F> void setField(Class<T> clazz, String name, Class<F> fieldType, T receiver, F value)
	{
		//TODO check if is instance field
		doChecked(() -> lookupField(clazz, name, fieldType).set(receiver, value));
	}

	private static <F> Field lookupField(Class<?> clazz, String name, Class<F> fieldType) throws NoSuchFieldException, ClassNotFoundException
	{
		Field field = clazz.getDeclaredField(name);
		if(!field.getType().equals(fieldType))
			throw new IllegalArgumentException("Field type mismatch");
		//isAccessible is deprecated. We can tolerate the inefficiency generated by always setting accessible.
		field.setAccessible(true);
		return field;
	}

	private static Method lookupMethod(Class<?> clazz, String name, List<Class<?>> paramTypes, Class<?> returnType) throws NoSuchMethodException, ClassNotFoundException
	{
		Method method = clazz.getDeclaredMethod(name, paramTypes.toArray(Class[]::new));
		if(!method.getReturnType().equals(returnType))
			throw new IllegalArgumentException("Return type mismatch");
		//isAccessible is deprecated. We can tolerate the inefficiency generated by always setting accessible.
		method.setAccessible(true);
		return method;
	}

	public static Runnable wrap(ThrowingRunnable body)
	{
		return () -> doChecked(body);
	}
	public static <R> Supplier<R> wrap(ThrowingSupplier<R> body)
	{
		return () -> doChecked(body);
	}
	public static <A, R> Function<A, R> wrap(ThrowingFunction<A, R> body)
	{
		return a -> doChecked(body, a);
	}
	public static void doChecked(ThrowingRunnable body)
	{
		doChecked(() ->
		{
			body.run();
			return null;
		});
	}
	public static <R> R doChecked(ThrowingSupplier<R> body)
	{
		return doChecked(a -> body.get(), null);
	}
	public static <A, R> R doChecked(ThrowingFunction<A, R> body, A a)
	{
		try
		{
			return body.apply(a);
		} catch(InvocationTargetException | InstantiationException | IllegalAccessException | NoSuchMethodException | NoSuchFieldException
				| ClassNotFoundException e)
		{
			//TODO throw correct exception type
			throw new RuntimeException(e);
		}
	}

	public static List<Class<?>> n2c(List<String> classnames)
	{
		return classnames.stream().map((Function<String, Class<?>>) ReflectionUtils::n2c).toList();
	}
	public static Class<?> n2c(String classname)
	{
		return doChecked(n ->
		{
			// @formatter:off
			if(n.equals(Boolean  .TYPE.getName())) return boolean.class;
			if(n.equals(Character.TYPE.getName())) return char   .class;
			if(n.equals(Byte     .TYPE.getName())) return byte   .class;
			if(n.equals(Short    .TYPE.getName())) return short  .class;
			if(n.equals(Integer  .TYPE.getName())) return int    .class;
			if(n.equals(Long     .TYPE.getName())) return long   .class;
			if(n.equals(Float    .TYPE.getName())) return float  .class;
			if(n.equals(Double   .TYPE.getName())) return double .class;
			if(n.equals(Void     .TYPE.getName())) return void   .class;
			// @formatter:on
			return Class.forName(n);
		}, classname);
	}

	public static List<String> c2n(Class<?>[] classes)
	{
		return c2n(Arrays.stream(classes)).toList();
	}
	public static List<String> c2n(List<Class<?>> classes)
	{
		return c2n(classes.stream()).toList();
	}
	private static Stream<String> c2n(Stream<Class<?>> classes)
	{
		return classes.map(ReflectionUtils::c2n);
	}
	public static String c2n(Class<?> clazz)
	{
		return clazz.getName();
	}

	/*
	public static Class<?> replacePrimitiveWithWrapper(Class<?> clazz)
	{
		if(clazz.isPrimitive())
		{
			// @formatter:off
			if(clazz == Boolean  .TYPE) return Boolean  .class;
			if(clazz == Character.TYPE) return Character.class;
			if(clazz == Byte     .TYPE) return Byte     .class;
			if(clazz == Short    .TYPE) return Short    .class;
			if(clazz == Integer  .TYPE) return Integer  .class;
			if(clazz == Long     .TYPE) return Long     .class;
			if(clazz == Float    .TYPE) return Float    .class;
			if(clazz == Double   .TYPE) return Double   .class;
			if(clazz == Void     .TYPE) return Void     .class;
			// @formatter:on
			throw new IllegalArgumentException("Unknown primitive type: " + clazz);
		}
		return clazz;
	}
	*/

	private ReflectionUtils()
	{}
}
